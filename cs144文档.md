## 项目介绍

项目来源于：https://cs144.github.io/

此项目仅实现了tcp协议的内容部分即该项目的前5部分。

对于每个实验的介绍部分都在上面的网址中的**Lab Assignment**中可下载相关pdf进行查看实验内容的文档介绍。

## 目录树

```
sponge
├── apps
├── build      代码构建
├── CMakeLists.txt
├── compile_commands.json -> build/compile_commands.json
├── doctests
├── etc
├── libsponge  源代码
├── README.md
├── tests
├── tun.sh
├── txrx.sh
└── writeups
```

## 环境搭建

在**Checkpoint 0**这个pdf文档中的**1 Set up GNU/Linux on your computer**部分中有详细的介绍。

推荐安装**CS144 VirtualBox**

环境推荐**ubuntu20.04**

https://stanford.edu/class/cs144/vm_howto/vm-howto-image.html

上述官方网址有详细的安装步骤，按照安装步骤即可配置好本实验的环境。

## 项目框架代码拉取

在官网每个lab的pdf介绍中都会有有一个**Getting started**的部分，该部分大概陈列了5到6个命令，按照该命令一步步执行即可拉取到每个lab分支的代码。

## 项目运行和测试的相关命令

测试文件位于 `sponge/tests/` 文件夹下，对应的 CMake 命令位于 `sponge/etc/test.cmake` 中。

在构建时使用`make check_lab1` `make check_lab2 ` `make check_lab3 ` `make check_lab4 `

最终整个项目的性能测试使用：`./apps/tcp_benchmark`

## 项目组成和结果展示

如图所示 [![image-20230313111322059](https://imgbed001.oss-cn-hangzhou.aliyuncs.com/img/68747470733a2f2f696d676265643030312e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f696d672f696d6167652d32303233303331333131313332323035392e706e67.png)](https://camo.githubusercontent.com/2ef8a504a3c9db11301a317d117a65f9d57bd1dc892905a50be8b59186a2b085/68747470733a2f2f696d676265643030312e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f696d672f696d6167652d32303233303331333131313332323035392e706e67)

本项目一共分为5部分：

- 字节流（byteStream）：对传输的数据进行读写操作、并且支持流量控制；
- 流重组器（StreamReassembler）：对传输过程中TCP段可能会出现乱序、丢失、重复、交叉重叠等错误状态进行处理，使其还原为原来的正确顺序；
- TCP接收器（TCPReceiver）：将接收到的数据送入流重组器中进行处理之后再传入字节流中，同时给发送方返回确认号（ack）和窗口大小（window size）实现对流量的控制；
- TCP发送器（TCPSender）：实现了重传定时器用于TCP的超时重传，同时对传输信息进行加工合成TCP段用于发送；
- TCP连接（TCPConnection）：将TCP接收器和发送器封装在一起从而实现完整的收发数据功能。

基于以上5部分，最终可以实现一个TCP协议。

压力测试如图所示：

```bash
$ ./apps/tcp_benchmark 
#----------------------------------------------------------------------------------
CPU-limited throughput                : 1.00 Gbit/s
CPU-limited throughput with reordering: 0.94 Gbit/s
```

## 项目常见询问点

### 1. 字节流细节

内部用一个**queue<char> _buff**实现。有一个容量**capacity**，可以用来查看是否缓冲区已满。还可以查看读写的字节数，以及是否到达数据末尾。**当缓冲区为空并且输入也结束时，即到达eof。**

### 2. 流重组器细节

**传输的字符串都要先写入字节流中，然后才以供接收方读取！！！！**

那么已经写入的都是已经排好序的字符串了。

**难点在于处理乱序、重叠、丢失、重复等情况**

自定义**struct segment，**并且重载了操作符< (因为需要用到set这个数据结构，关系到排序问题) 按照下标索引进行排序。

### 3. 项目难点

主要在于流重组器中对于写入字符串的处理，即如何处理乱序、重叠、丢失、重复等情况，这部分可以**重点参考lab1的文档**中对于流重组器中的细节描述！

